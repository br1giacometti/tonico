{"ast":null,"code":"import _defineProperty from \"C:/Users/Bruno/Desktop/tienda/nextjs-shopify-master/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/* \n  prepareVariantsWithOptions()\n\n  This function changes the structure of the variants to\n  more easily get at their options. The original data \n  structure looks like this:\n\n  {\n    \"shopifyId\": \"Z2lkOi8vc2hvcGlmeS9Qcm9kdWN0VmFyaWFudC8zMTc4NDQ4MTAzMDE4OA==\",\n    \"selectedOptions\": [\n      {\n        \"name\": \"Color\",\n        \"value\": \"Red\"\n      },\n      {\n        \"name\": \"Size\",\n        \"value\": \"Small\"\n      }\n    ]\n  },\n\n  This function accepts that and outputs a data structure that looks like this:\n\n  {\n    \"shopifyId\": \"Z2lkOi8vc2hvcGlmeS9Qcm9kdWN0VmFyaWFudC8zMTc4NDQ4MTAzMDE4OA==\",\n    \"color\": \"Red\",\n    \"size\": \"Small\"\n  },\n*/\nexport function prepareVariantsWithOptions(variants) // variants: Readonly<ShopifyBuy.ProductVariant[]>\n{\n  return variants.map(function (variant) {\n    var _variant$selectedOpti;\n\n    // TODO: look into types, prob need update in @types/shopify-buy\n    // convert the options to a dictionary instead of an array\n    var optionsDictionary = (_variant$selectedOpti = variant.selectedOptions) === null || _variant$selectedOpti === void 0 ? void 0 : _variant$selectedOpti.reduce(function (options, option) {\n      var _option$name;\n\n      options[\"\".concat(option === null || option === void 0 ? void 0 : (_option$name = option.name) === null || _option$name === void 0 ? void 0 : _option$name.toLowerCase())] = option === null || option === void 0 ? void 0 : option.value;\n      return options;\n    }, {}); // return an object with all of the variant properties + the options at the top level\n\n    return _objectSpread(_objectSpread({}, optionsDictionary), variant);\n  });\n}\nexport var getPrice = function getPrice(price, currency) {\n  return Intl.NumberFormat(undefined, {\n    currency: currency,\n    minimumFractionDigits: 2,\n    style: 'currency'\n  }).format(parseFloat(price ? price : '0'));\n};\n/*\n  prepareVariantsImages()\n\n  This function distills the variants images into a non-redundant\n  group that includes an option 'key' (most likely color). The\n  datastructure coming into this function looks like this:\n\n  {\n    \"shopifyId\": \"Z2lkOi8vc2hvcGlmeS9Qcm9kdWN0VmFyaWFudC8zMTc4NDQ4MTAzMDE4OA==\",\n    \"image\": image1,\n    \"color\": \"Red\",\n    \"size\": \"Small\"\n  },\n  {\n    \"shopifyId\": \"Z2lkOi8vc2hvcGlmeS9Qcm9kdWN0VmFyaW1l2C8zMTc4NDQ4MTAzMDE4OA==\",\n    \"image\": image1,\n    \"color\": \"Red\",\n    \"size\": \"Medium\"\n  },\n\n  And condenses them so that there is only one unique\n  image per key value:\n\n  {\n    \"image\": image1,\n    \"color\": \"Red\",\n  },\n*/\n\nexport function prepareVariantsImages(variants, // variants: Readonly<GatsbyTypes.ShopifyProductVariant[]>,\noptionKey) {\n  // Go through the variants and reduce them into non-redundant\n  // images by optionKey. Output looks like this:\n  // {\n  //   [optionKey]: image\n  // }\n  var imageDictionary = variants.reduce(function (images, variant) {\n    if (variant[optionKey]) {\n      images[variant[optionKey]] = variant.image;\n    }\n\n    return images;\n  }, {}); // prepare an array of image objects that include both the image\n  // and the optionkey value.\n\n  var images = Object.keys(imageDictionary).map(function (key) {\n    var _ref;\n\n    return _ref = {}, _defineProperty(_ref, optionKey, key), _defineProperty(_ref, \"src\", imageDictionary[key]), _ref;\n  });\n  return images;\n}","map":{"version":3,"sources":["C:/Users/Bruno/Desktop/tienda/nextjs-shopify-master/lib/shopify/storefront-data-hooks/src/utils/product.ts"],"names":["prepareVariantsWithOptions","variants","map","variant","optionsDictionary","selectedOptions","reduce","options","option","name","toLowerCase","value","getPrice","price","currency","Intl","NumberFormat","undefined","minimumFractionDigits","style","format","parseFloat","prepareVariantsImages","optionKey","imageDictionary","images","image","Object","keys","key"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAO,SAASA,0BAAT,CACLC,QADK,EAEL;AACA;AACA,SAAOA,QAAQ,CAACC,GAAT,CAAa,UAACC,OAAD,EAAa;AAAA;;AAC/B;AACA;AACA,QAAMC,iBAAiB,4BAAGD,OAAO,CAACE,eAAX,0DAAG,sBAAyBC,MAAzB,CACxB,UAACC,OAAD,EAAeC,MAAf,EAA+B;AAAA;;AAC7BD,MAAAA,OAAO,WAAIC,MAAJ,aAAIA,MAAJ,uCAAIA,MAAM,CAAEC,IAAZ,iDAAI,aAAcC,WAAd,EAAJ,EAAP,GAA4CF,MAA5C,aAA4CA,MAA5C,uBAA4CA,MAAM,CAAEG,KAApD;AACA,aAAOJ,OAAP;AACD,KAJuB,EAKxB,EALwB,CAA1B,CAH+B,CAW/B;;AACA,2CACKH,iBADL,GAEKD,OAFL;AAID,GAhBM,CAAP;AAiBD;AAED,OAAO,IAAMS,QAAQ,GAAG,SAAXA,QAAW,CAACC,KAAD,EAAgBC,QAAhB;AAAA,SACtBC,IAAI,CAACC,YAAL,CAAkBC,SAAlB,EAA6B;AAC3BH,IAAAA,QAAQ,EAARA,QAD2B;AAE3BI,IAAAA,qBAAqB,EAAE,CAFI;AAG3BC,IAAAA,KAAK,EAAE;AAHoB,GAA7B,EAIGC,MAJH,CAIUC,UAAU,CAACR,KAAK,GAAGA,KAAH,GAAW,GAAjB,CAJpB,CADsB;AAAA,CAAjB;AAOP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASS,qBAAT,CACLrB,QADK,EAEL;AACAsB,SAHK,EAIE;AACP;AACA;AACA;AACA;AACA;AACA,MAAMC,eAAe,GAAGvB,QAAQ,CAACK,MAAT,CACtB,UAACmB,MAAD,EAAStB,OAAT,EAAqB;AACnB,QAAIA,OAAO,CAACoB,SAAD,CAAX,EAAwB;AACtBE,MAAAA,MAAM,CAACtB,OAAO,CAACoB,SAAD,CAAR,CAAN,GAA6BpB,OAAO,CAACuB,KAArC;AACD;;AACD,WAAOD,MAAP;AACD,GANqB,EAOtB,EAPsB,CAAxB,CANO,CAgBP;AACA;;AACA,MAAMA,MAAM,GAAGE,MAAM,CAACC,IAAP,CAAYJ,eAAZ,EAA6BtB,GAA7B,CAAiC,UAAC2B,GAAD,EAAS;AAAA;;AACvD,4CACGN,SADH,EACeM,GADf,gCAEOL,eAAe,CAACK,GAAD,CAFtB;AAID,GALc,CAAf;AAOA,SAAOJ,MAAP;AACD","sourcesContent":["/* \n  prepareVariantsWithOptions()\n\n  This function changes the structure of the variants to\n  more easily get at their options. The original data \n  structure looks like this:\n\n  {\n    \"shopifyId\": \"Z2lkOi8vc2hvcGlmeS9Qcm9kdWN0VmFyaWFudC8zMTc4NDQ4MTAzMDE4OA==\",\n    \"selectedOptions\": [\n      {\n        \"name\": \"Color\",\n        \"value\": \"Red\"\n      },\n      {\n        \"name\": \"Size\",\n        \"value\": \"Small\"\n      }\n    ]\n  },\n\n  This function accepts that and outputs a data structure that looks like this:\n\n  {\n    \"shopifyId\": \"Z2lkOi8vc2hvcGlmeS9Qcm9kdWN0VmFyaWFudC8zMTc4NDQ4MTAzMDE4OA==\",\n    \"color\": \"Red\",\n    \"size\": \"Small\"\n  },\n*/\n\nexport function prepareVariantsWithOptions(\n  variants: any[]\n  // variants: Readonly<ShopifyBuy.ProductVariant[]>\n) {\n  return variants.map((variant) => {\n    // TODO: look into types, prob need update in @types/shopify-buy\n    // convert the options to a dictionary instead of an array\n    const optionsDictionary = variant.selectedOptions?.reduce(\n      (options: any, option: any) => {\n        options[`${option?.name?.toLowerCase()}`] = option?.value\n        return options\n      },\n      {}\n    )\n\n    // return an object with all of the variant properties + the options at the top level\n    return {\n      ...optionsDictionary,\n      ...variant,\n    }\n  }) as any[]\n}\n\nexport const getPrice = (price: string, currency: string) =>\n  Intl.NumberFormat(undefined, {\n    currency,\n    minimumFractionDigits: 2,\n    style: 'currency',\n  }).format(parseFloat(price ? price : '0'))\n\n/*\n  prepareVariantsImages()\n\n  This function distills the variants images into a non-redundant\n  group that includes an option 'key' (most likely color). The\n  datastructure coming into this function looks like this:\n\n  {\n    \"shopifyId\": \"Z2lkOi8vc2hvcGlmeS9Qcm9kdWN0VmFyaWFudC8zMTc4NDQ4MTAzMDE4OA==\",\n    \"image\": image1,\n    \"color\": \"Red\",\n    \"size\": \"Small\"\n  },\n  {\n    \"shopifyId\": \"Z2lkOi8vc2hvcGlmeS9Qcm9kdWN0VmFyaW1l2C8zMTc4NDQ4MTAzMDE4OA==\",\n    \"image\": image1,\n    \"color\": \"Red\",\n    \"size\": \"Medium\"\n  },\n\n  And condenses them so that there is only one unique\n  image per key value:\n\n  {\n    \"image\": image1,\n    \"color\": \"Red\",\n  },\n*/\n\nexport function prepareVariantsImages(\n  variants: any[],\n  // variants: Readonly<GatsbyTypes.ShopifyProductVariant[]>,\n  optionKey: any\n): any[] {\n  // Go through the variants and reduce them into non-redundant\n  // images by optionKey. Output looks like this:\n  // {\n  //   [optionKey]: image\n  // }\n  const imageDictionary = variants.reduce<Record<string, ShopifyBuy.Image>>(\n    (images, variant) => {\n      if (variant[optionKey]) {\n        images[variant[optionKey]] = variant.image\n      }\n      return images\n    },\n    {}\n  )\n\n  // prepare an array of image objects that include both the image\n  // and the optionkey value.\n  const images = Object.keys(imageDictionary).map((key) => {\n    return {\n      [optionKey]: key,\n      src: imageDictionary[key],\n    }\n  })\n\n  return images\n}\n"]},"metadata":{},"sourceType":"module"}