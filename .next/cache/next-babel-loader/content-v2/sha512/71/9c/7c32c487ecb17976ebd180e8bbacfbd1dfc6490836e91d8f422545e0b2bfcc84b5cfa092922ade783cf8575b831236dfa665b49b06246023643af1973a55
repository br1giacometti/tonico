{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport * as qs from 'qs';\nexport async function getAllProducts(config, limit = 100, offset = 0) {\n  const productsContent = (await fetch(`https://cdn.builder.io/api/v2/content/${config.productsModel}?apiKey=${config.apiKey}&limit=${limit}&offset=${offset}&cachebust=true`).then(res => res.json())).results;\n  return productsContent.map(pr => pr.data);\n}\nexport async function searchProducts(config, searchString, limit = 100, offset = 0) {\n  const query = qs.stringify({\n    fields: ['data'],\n    limit,\n    offset,\n    apiKey: config.apiKey\n  }, {\n    allowDots: true\n  });\n  const productsContent = (await fetch(`https://cdn.builder.io/api/v2/content/${config.productsModel}?${query}&query.data.title=${JSON.stringify({\n    $regex: `${searchString}`,\n    $options: 'i'\n  })}`).then(res => res.json())).results;\n  return (productsContent === null || productsContent === void 0 ? void 0 : productsContent.map(product => product.data)) || [];\n}\nexport async function getAllProductPaths(config, limit) {\n  const products = await getAllProducts(config, limit);\n  return (products === null || products === void 0 ? void 0 : products.map(entry => entry.handle)) || [];\n}\nexport async function getProduct(config, options) {\n  var _productsContent$;\n\n  if (Boolean(options.id) === Boolean(options.handle)) {\n    throw new Error('Either a handle or id is required');\n  }\n\n  const query = qs.stringify({\n    limit: 1,\n    apiKey: config.apiKey,\n    query: {\n      data: options.id ? {\n        id: {\n          $eq: options.id\n        }\n      } : {\n        handle: {\n          $eq: options.handle\n        }\n      }\n    }\n  });\n  const productsContent = (await fetch(`https://cdn.builder.io/api/v2/content/${config.productsModel}?${query}`).then(res => res.json())).results;\n\n  if (options.withContent) {\n    return productsContent[0];\n  }\n\n  return (_productsContent$ = productsContent[0]) === null || _productsContent$ === void 0 ? void 0 : _productsContent$.data;\n}\n/**\n * Collections\n */\n\nexport async function getAllCollections(config, limit = 20, offset = 0, fields) {\n  const query = qs.stringify({\n    fields: fields || 'data',\n    limit,\n    offset,\n    apiKey: config.apiKey,\n    cachebust: true\n  }, {\n    allowDots: true\n  });\n  const collectionsContent = (await fetch(`https://cdn.builder.io/api/v2/content/${config.collectionsModel}?${query}`).then(res => res.json())).results;\n  return (collectionsContent === null || collectionsContent === void 0 ? void 0 : collectionsContent.map(entry => entry.data)) || [];\n}\nexport async function searchCollections(config, searchString, limit = 100, offset = 0) {\n  const query = qs.stringify({\n    fields: ['data'],\n    limit,\n    offset,\n    apiKey: config.apiKey\n  }, {\n    allowDots: true\n  });\n  const collectionsContent = (await fetch(`https://cdn.builder.io/api/v2/content/${config.collectionsModel}?${query}&query.$or=${JSON.stringify([{\n    'data.description': {\n      $regex: `${searchString}`\n    }\n  }, {\n    'data.title': {\n      $regex: `${searchString}`\n    }\n  }])}`).then(res => res.json())).results;\n  return (collectionsContent === null || collectionsContent === void 0 ? void 0 : collectionsContent.map(entry => entry.data)) || [];\n}\nexport async function getAllCollectionPaths(config, limit) {\n  const collections = await getAllCollections(config, limit);\n  return (collections === null || collections === void 0 ? void 0 : collections.map(entry => entry.handle)) || [];\n}\nexport async function getCollection(config, options) {\n  var _collectionsContent$;\n\n  if (Boolean(options.id) === Boolean(options.handle)) {\n    throw new Error('Either a handle or id is required');\n  }\n\n  const query = qs.stringify({\n    limit: 1,\n    apiKey: config.apiKey,\n    cachebust: true,\n    query: {\n      data: options.id ? {\n        id: {\n          $eq: options.id\n        }\n      } : {\n        handle: {\n          $eq: options.handle\n        }\n      }\n    }\n  });\n  const collectionsContent = (await fetch(`https://cdn.builder.io/api/v2/content/${config.collectionsModel}?${query}`).then(res => res.json())).results;\n  const collection = (_collectionsContent$ = collectionsContent[0]) === null || _collectionsContent$ === void 0 ? void 0 : _collectionsContent$.data;\n\n  if (config.isDemo) {\n    return collection;\n  }\n\n  const productsQuery = _objectSpread(_objectSpread({\n    limit: 20,\n    handle: collection === null || collection === void 0 ? void 0 : collection.handle\n  }, options.productsQuery), {}, {\n    apiKey: config.apiKey\n  });\n\n  const {\n    products,\n    nextPageCursor,\n    hasNextPage\n  } = await getCollectionProducts(productsQuery);\n  return _objectSpread(_objectSpread({}, collection), {}, {\n    products,\n    nextPageCursor,\n    hasNextPage\n  });\n}\nexport const getCollectionProducts = productsQuery => {\n  const search = qs.stringify(productsQuery);\n  return fetch(`https://cdn.builder.io/api/v1/shopify-sync/collection-products?${search}`).then(res => res.json());\n};","map":{"version":3,"sources":["C:/Users/Bruno/Desktop/tienda/nextjs-shopify-master/lib/shopify/storefront-data-hooks/src/api/operations-builder.ts"],"names":["qs","getAllProducts","config","limit","offset","productsContent","fetch","productsModel","apiKey","then","res","json","results","map","pr","data","searchProducts","searchString","query","stringify","fields","allowDots","JSON","$regex","$options","product","getAllProductPaths","products","entry","handle","getProduct","options","Boolean","id","Error","$eq","withContent","getAllCollections","cachebust","collectionsContent","collectionsModel","searchCollections","getAllCollectionPaths","collections","getCollection","collection","isDemo","productsQuery","nextPageCursor","hasNextPage","getCollectionProducts","search"],"mappings":"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","sourcesContent":["import * as qs from 'qs'\n\nexport interface BuillderConfig {\n  apiKey: string\n  productsModel: string\n  collectionsModel: string\n  isDemo?: boolean\n}\n\nexport interface CollectionProductsQuery {\n  handle: string\n  limit?: number\n  cursor?: string\n  apiKey: string\n}\n\nexport async function getAllProducts(\n  config: BuillderConfig,\n  limit = 100,\n  offset = 0\n) {\n  const productsContent = (\n    await fetch(\n      `https://cdn.builder.io/api/v2/content/${config.productsModel}?apiKey=${config.apiKey}&limit=${limit}&offset=${offset}&cachebust=true`\n    ).then((res) => res.json())\n  ).results\n\n  return productsContent.map((pr: any) => pr.data)\n}\n\nexport async function searchProducts(\n  config: BuillderConfig,\n  searchString: string,\n  limit = 100,\n  offset = 0\n) {\n  const query = qs.stringify(\n    {\n      fields: ['data'],\n      limit,\n      offset,\n      apiKey: config.apiKey,\n    },\n    { allowDots: true }\n  )\n\n  const productsContent = (\n    await fetch(\n      `https://cdn.builder.io/api/v2/content/${\n        config.productsModel\n      }?${query}&query.data.title=${JSON.stringify({\n        $regex: `${searchString}`,\n        $options: 'i',\n      })}`\n    ).then((res) => res.json())\n  ).results\n  return productsContent?.map((product: any) => product.data) || []\n}\n\nexport async function getAllProductPaths(\n  config: BuillderConfig,\n  limit?: number\n): Promise<string[]> {\n  const products: any[] = await getAllProducts(config, limit)\n  return products?.map((entry) => entry.handle) || []\n}\n\nexport async function getProduct(\n  config: BuillderConfig,\n  options: { id?: string; handle?: string; withContent?: boolean }\n) {\n  if (Boolean(options.id) === Boolean(options.handle)) {\n    throw new Error('Either a handle or id is required')\n  }\n  const query = qs.stringify({\n    limit: 1,\n    apiKey: config.apiKey,\n    query: {\n      data: options.id\n        ? {\n            id: { $eq: options.id },\n          }\n        : {\n            handle: { $eq: options.handle },\n          },\n    },\n  })\n\n  const productsContent = (\n    await fetch(\n      `https://cdn.builder.io/api/v2/content/${config.productsModel}?${query}`\n    ).then((res) => res.json())\n  ).results\n\n  if (options.withContent) {\n    return productsContent[0]\n  }\n  return productsContent[0]?.data\n}\n\n/**\n * Collections\n */\n\nexport async function getAllCollections(\n  config: BuillderConfig,\n  limit = 20,\n  offset = 0,\n  fields?: string\n) {\n  const query = qs.stringify(\n    {\n      fields: fields || 'data',\n      limit,\n      offset,\n      apiKey: config.apiKey,\n      cachebust: true,\n    },\n    { allowDots: true }\n  )\n\n  const collectionsContent = (\n    await fetch(\n      `https://cdn.builder.io/api/v2/content/${config.collectionsModel}?${query}`\n    ).then((res) => res.json())\n  ).results\n\n  return collectionsContent?.map((entry: any) => entry.data) || []\n}\n\nexport async function searchCollections(\n  config: BuillderConfig,\n  searchString: string,\n  limit = 100,\n  offset = 0\n) {\n  const query = qs.stringify(\n    {\n      fields: ['data'],\n      limit,\n      offset,\n      apiKey: config.apiKey,\n    },\n    { allowDots: true }\n  )\n\n  const collectionsContent = (\n    await fetch(\n      `https://cdn.builder.io/api/v2/content/${\n        config.collectionsModel\n      }?${query}&query.$or=${JSON.stringify([\n        {\n          'data.description': { $regex: `${searchString}` },\n        },\n        {\n          'data.title': { $regex: `${searchString}` },\n        },\n      ])}`\n    ).then((res) => res.json())\n  ).results\n  return collectionsContent?.map((entry: any) => entry.data) || []\n}\n\nexport async function getAllCollectionPaths(\n  config: BuillderConfig,\n  limit?: number\n): Promise<string[]> {\n  const collections: any[] = await getAllCollections(config, limit)\n  return collections?.map((entry) => entry.handle) || []\n}\n\nexport async function getCollection(\n  config: BuillderConfig,\n  options: {\n    id?: string\n    handle?: string\n    productsQuery?: Omit<CollectionProductsQuery, 'handle'>\n  }\n) {\n  if (Boolean(options.id) === Boolean(options.handle)) {\n    throw new Error('Either a handle or id is required')\n  }\n  const query = qs.stringify({\n    limit: 1,\n    apiKey: config.apiKey,\n    cachebust: process.env.NODE_ENV !== 'production',\n    query: {\n      data: options.id\n        ? {\n            id: { $eq: options.id },\n          }\n        : {\n            handle: { $eq: options.handle },\n          },\n    },\n  })\n\n  const collectionsContent = (\n    await fetch(\n      `https://cdn.builder.io/api/v2/content/${config.collectionsModel}?${query}`\n    ).then((res) => res.json())\n  ).results\n\n  const collection = collectionsContent[0]?.data\n  if (config.isDemo) {\n    return collection\n  }\n  const productsQuery = {\n    limit: 20,\n    handle: collection?.handle,\n    ...options.productsQuery,\n    apiKey: config.apiKey,\n  }\n  const { products, nextPageCursor, hasNextPage } = await getCollectionProducts(\n    productsQuery\n  )\n\n  return {\n    ...collection,\n    products,\n    nextPageCursor,\n    hasNextPage,\n  }\n}\n\nexport const getCollectionProducts = (\n  productsQuery: CollectionProductsQuery\n): Promise<{\n  nextPageCursor: string\n  products: any[]\n  hasNextPage: boolean\n}> => {\n  const search = qs.stringify(productsQuery)\n  return fetch(\n    `https://cdn.builder.io/api/v1/shopify-sync/collection-products?${search}`\n  ).then((res) => res.json())\n}\n"]},"metadata":{},"sourceType":"module"}