import React, { useState, useEffect } from 'react';
import { useThemeUI, jsx, __ThemeUIInternalBaseThemeProvider, merge } from '@theme-ui/core';
import { __internalGetUseRootStyles, css, get } from '@theme-ui/css';
import { Global } from '@emotion/react';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const toVarName = key => `--theme-ui-${key.replace('-__default', '')}`;

const toVarValue = key => `var(${toVarName(key)})`;

const join = (...args) => args.filter(Boolean).join('-');
const reservedKeys = {
  useCustomProperties: true,
  initialColorModeName: true,
  printColorModeName: true,
  initialColorMode: true,
  useLocalStorage: true
};


const toCustomProperties = (obj, parent, themeKey) => {
  const next = Array.isArray(obj) ? [] : {};

  for (let key in obj) {
    const value = obj[key];
    const name = join(parent, key);

    if (value && typeof value === 'object') {
      next[key] = toCustomProperties(value, name);
      continue;
    }

    if (reservedKeys[key]) {
      next[key] = value;
      continue;
    }
    next[key] = toVarValue(name);
  }

  return next;
};
const objectToVars = (parent, obj) => {
  let vars = {};

  for (let key in obj) {
    if (key === 'modes') continue;
    const name = join(parent, key);
    const value = obj[key];

    if (value && typeof value === 'object') {
      vars = _extends({}, vars, objectToVars(name, value));
    } else {
      vars[toVarName(name)] = value;
    }
  }

  return vars;
}; // create root styles for color modes

const createColorStyles = (theme = {}) => {
  const rootStyles = __internalGetUseRootStyles(theme);

  const colors = theme.rawColors || theme.colors;
  if (!colors || rootStyles.rootStyles === false) return {};

  if (theme.useCustomProperties === false) {
    return css({
      [rootStyles.scope]: {
        color: 'text',
        bg: 'background'
      }
    })(theme);
  }

  const {
    initialColorModeName,
    printColorModeName
  } = theme;
  const modes = colors.modes || {};
  const styles = objectToVars('colors', colors);
  Object.keys(modes).forEach(mode => {
    const key = `&.theme-ui-${mode}`;
    styles[key] = objectToVars('colors', modes[mode]);
  });

  if (printColorModeName) {
    const mode = printColorModeName === 'initial' || printColorModeName === initialColorModeName ? colors : modes[printColorModeName];
    styles['@media print'] = objectToVars('colors', mode);
  }

  const colorToVarValue = color => toVarValue(`colors-${color}`);

  return css({
    [rootStyles.scope]: _extends({}, styles, {
      color: colorToVarValue('text'),
      bg: colorToVarValue('background')
    })
  })(theme);
};

const STORAGE_KEY = 'theme-ui-color-mode';
const storage = {
  get: () => {
    try {
      return window.localStorage.getItem(STORAGE_KEY);
    } catch (e) {
      console.warn('localStorage is disabled and color mode might not work as expected.', 'Please check your Site Settings.', e);
    }
  },
  set: value => {
    try {
      window.localStorage.setItem(STORAGE_KEY, value);
    } catch (e) {
      console.warn('localStorage is disabled and color mode might not work as expected.', 'Please check your Site Settings.', e);
    }
  }
};

const getPreferredColorScheme = () => {
  if (typeof window !== 'undefined' && window.matchMedia) {
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
      return 'dark';
    }

    if (window.matchMedia('(prefers-color-scheme: light)').matches) {
      return 'light';
    }
  }

  return null;
};

const getModeFromClass = () => {
  let mode;

  if (typeof document !== 'undefined') {
    document.documentElement.classList.forEach(className => {
      if (className.startsWith('theme-ui-')) {
        mode = className.replace('theme-ui-', '');
      }
    });
  }

  return mode;
};

const useColorModeState = (theme = {}) => {
  let [mode, setMode] = useState(() => {
    const modeFromClass = getModeFromClass();

    if (modeFromClass) {
      return modeFromClass;
    }

    const preferredMode = theme.useColorSchemeMediaQuery !== false && getPreferredColorScheme();
    return preferredMode || theme.initialColorModeName;
  }); // on first render, we read the color mode from localStorage and
  // clear the class on document element body

  useEffect(() => {
    const stored = theme.useLocalStorage !== false && storage.get();

    if (typeof document !== 'undefined') {
      document.documentElement.classList.remove('theme-ui-' + stored);
      document.body.classList.remove('theme-ui-' + stored);
    }

    if (stored && stored !== mode) {
      mode = stored;
      setMode(stored);
    }
  }, []); // when mode changes, we save it to localStorage

  React.useEffect(() => {
    if (mode && theme.useLocalStorage !== false) {
      storage.set(mode);
    }
  }, [mode]);

  if (process.env.NODE_ENV !== 'production') {
    if (theme.colors && theme.colors.modes && theme.initialColorModeName && Object.keys(theme.colors.modes).indexOf(theme.initialColorModeName) > -1) {
      console.warn('The `initialColorModeName` value should be a unique name' + ' and cannot reference a key in `theme.colors.modes`.');
    }
  }

  return [mode, setMode];
};

function useColorMode() {
  const {
    colorMode,
    setColorMode
  } = useThemeUI();

  if (typeof setColorMode !== 'function') {
    throw new Error(`[useColorMode] requires the ColorModeProvider component`);
  } // We're allowing the user to specify a narrower type for its color mode name.


  return [colorMode, setColorMode];
}

const applyColorMode = (theme, mode) => {
  if (!mode) return _extends({}, theme);
  const modes = get(theme, 'colors.modes', {});
  return merge.all({}, theme, {
    colors: get(modes, mode, {})
  });
};

const ColorModeProvider = ({
  children
}) => {
  const outer = useThemeUI();
  const [colorMode, setColorMode] = useColorModeState(outer.theme);
  const theme = applyColorMode(outer.theme || {}, colorMode);

  if (theme.useCustomProperties !== false) {
    // TODO: This mutation is less than ideal
    // We could save custom properties to `theme.colorVars`,
    // But it's infeasible to do this because of how the packages are split.
    theme.rawColors = theme.colors;
    theme.colors = toCustomProperties(theme.colors, 'colors');
  }

  const context = _extends({}, outer, {
    theme,
    colorMode,
    setColorMode
  });

  const isTopLevelColorModeProvider = outer.setColorMode === undefined;
  return jsx(__ThemeUIInternalBaseThemeProvider, {
    context
  }, isTopLevelColorModeProvider ? jsx(Global, {
    styles: () => {
      return createColorStyles(theme);
    }
  }) : jsx('div', {
    className: 'theme-ui__nested-color-mode-provider',
    // TODO: This could be refactored a bit.
    style: createColorStyles(theme)[__internalGetUseRootStyles(theme).scope]
  }), children);
};
const noflash = `(function() { try {
  var mode = localStorage.getItem('theme-ui-color-mode');
  if (!mode) return
  document.documentElement.classList.add('theme-ui-' + mode);
  document.body.classList.add('theme-ui-' + mode);
} catch (e) {} })();`;
const InitializeColorMode = () => jsx('script', {
  key: 'theme-ui-no-flash',
  dangerouslySetInnerHTML: {
    __html: noflash
  }
});

export { ColorModeProvider, InitializeColorMode, useColorMode };
//# sourceMappingURL=index.modern.js.map
